<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Arena</title>
    <style>
        body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: linear-gradient(to bottom, #2a5298, #1e3c72);
    color: #ffffff;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    
}

.container {
    max-width: 1200px;
    width: 100%;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
}

.start-button, .add-section-button, .randomize-all-button {
    background-color: #2ecc71;
    color: white;
    border: none;
    padding: 15px 30px;
    font-size: 18px;
    cursor: pointer;
    margin: 5px;
    transition: background-color 0.3s;
}

.start-button:hover, .add-section-button:hover, .randomize-all-button:hover {
    background-color: #27ae60;
}

.sorting-sections {
    display: flex;
    flex-wrap: wrap; /* Allow wrapping to a new line */
    justify-content: center; /* Center the sections */
    margin-top: 20px;
}

.sorting-section {
    background-color: #34495e;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    padding: 20px;
    margin: 10px;
    flex: 1 1 300px; /* Allow sections to grow and shrink */
    min-width: 300px; /* Minimum width for responsiveness */
    max-width: 600px; /* Maximum width to prevent overflow */
}

.algorithm-dropdown {
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 5px;
    border: none;
    background-color:     #2c3e50;
    color: white;
    transition: background-color 0.3s;
}

.algorithm-dropdown:hover {
    background-color: #34495e;
}

.visualization {
    height: 200px; /* Set a fixed height for the visualization area */
    background-color: #2980b9; /* Placeholder color for the visualization area */
    margin-bottom: 10px;
    border-radius: 5px;
    display: flex; /* Use flexbox to align bars */
    align-items: flex-end; /* Align bars to the bottom */
    overflow: hidden; /* Prevent bars from overflowing */
}
.speed-control {
    width: 100%;
    margin-bottom: 10px;
}

.randomize-button {
    background-color: #e67e22;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.randomize-button:hover {
    background-color: #d35400;
}

.stats {
    margin-top: 10px;
}

.stats p {
    margin: 5px 0;
}

.description {
    margin-top: 10px;
    font-size: 14px;
    color: #bdc3c7;
}

.results-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    background-color: #34495e;
    border-radius: 10px;
    overflow: hidden;
}

.results-table th, .results-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #2c3e50;
}

.results-table th {
    background-color: #2c3e50;
}

.results-table tr:nth-child(even) {
    background-color: #2c3e50;
}

.results-table tr:hover {
    background-color: #3b5998;
}

@media (max-width: 768px) {
    .sorting-sections {
        flex-direction: column; /* Stack sections vertically on smaller screens */
        align-items: center;
    }

    .sorting-section {
        width: 100%; /* Full width for each section on small screens */
        margin: 10px 0;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>Sorting Algorithms Arena</h1>
        <button class="start-button">Start Sorting</button>
        <button class="add-section-button">+</button>
        <button class="randomize-all-button">Randomize All</button>
        <br>
        <label for="common-speed-slider">Sorting Speed: <span id="slider-value">5</span></label>
        <input type="range" id="common-speed-slider" min="1" max="10" value="5" style="width: 100%; margin-top: 20px;">

        <div class="sorting-sections" id="sorting-sections">
            


        </div>

        <table class="results-table">
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Swaps</th>
                    <th>Comparisons</th>
                    <th>Time Taken</th>
                    <th>Final Sorted Array</th>
                </tr>
            </thead>
            <tbody>
                <!-- Results will be populated here -->
            </tbody>
        </table>
    </div>
    <script>
        const slider = document.getElementById('common-speed-slider');
const sliderValueDisplay = document.getElementById('slider-value');

slider.addEventListener('input', () => {
    sliderValueDisplay.textContent = slider.value; // Update displayed value
});
document.addEventListener('DOMContentLoaded', () => {
    const addSectionButton = document.querySelector('.add-section-button');
    const startButton = document.querySelector('.start-button');
    const randomizeAllButton = document.querySelector('.randomize-all-button');
    const sortingSectionsContainer = document.getElementById('sorting-sections');
    const commonSpeedSlider = document.getElementById('common-speed-slider');

    // Function to create a new sorting section
    function createSortingSection() {
        const section = document.createElement('div');
        section.classList.add('sorting-section');
        section.innerHTML = `
            <h2>Sorting Algorithm</h2>
            <select class="algorithm-dropdown">
                <option value="bubble">Bubble Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="merge">Merge Sort</option>
                 <option value="insertion">Insertion Sort</option>
            <option value="selection">Selection Sort</option> 
            </select>
            <div class="visualization"></div>
            <button class="randomize-button">Randomize Array</button>
            <button class="remove-button">Remove</button>
            <div class="stats">
                <p>Swaps: <span class="swaps">0</span></p>
                <p>Comparisons: <span class="comparisons">0</span></p>
                <p>Time Taken: <span class="time">0ms</span></p>
            </div>
            
        `;
        sortingSectionsContainer.appendChild(section);

        // Add event listener for the randomize button
        const randomizeButton = section.querySelector('.randomize-button');
        randomizeButton.addEventListener('click', () => {
            randomizeArray(section);
        });

        // Add event listener for the remove button
        const removeButton = section.querySelector('.remove-button');
        removeButton.addEventListener('click', () => {
            section.remove(); // Remove the sorting section
        });
    }

    // Function to randomize the array in a sorting section
    function randomizeArray(section) {
        const visualization = section.querySelector('.visualization');
        const arraySize = 20; // Set the number of bars to 20
        const array = Array.from({ length: arraySize }, () => Math.floor(Math.random() * 100));
        
        // Clear previous visualization
        visualization.innerHTML = '';

        // Create bars for each value in the array
        array.forEach(value => {
            const bar = document.createElement('div');
            bar.style.height = `${value * 2}px`; // Scale the height for better visibility
            bar.style.width = '30px'; // Adjusted width for each bar
            bar.style.backgroundColor = '#3498db'; // Color of the bars
            bar.style.margin = '0 2px'; // Spacing between bars
            bar.style.borderRadius = '5px'; // Rounded corners for bars
            bar.style.position = 'relative'; // Set position to relative for tooltip positioning

            // Create tooltip
            const tooltip = document.createElement('span');
            tooltip.textContent = value; // Set the tooltip text to the value
            tooltip.style.position = 'absolute';
            tooltip.style.bottom = '100%'; // Position above the bar
            tooltip.style.left = '50%'; // Center the tooltip
            tooltip.style.transform = 'translateX(-50%)'; // Center the tooltip
            tooltip.style.backgroundColor = '#333'; // Tooltip background color
            tooltip.style.color = '#fff'; // Tooltip text color
            tooltip.style.padding = '5px';
            tooltip.style.borderRadius = '5px';
            tooltip.style.visibility = 'hidden'; // Hide tooltip by default
            tooltip.style.opacity = '0'; // Make it transparent
            tooltip.style.transition = 'opacity 0.3s'; // Smooth transition for visibility

            // Show tooltip on hover
            bar.addEventListener('mouseenter', () => {
                tooltip.style.visibility = 'visible';
                tooltip.style.opacity = '1'; // Make it visible
            });

            // Hide tooltip when not hovering
            bar.addEventListener('mouseleave', () => {
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0'; // Make it transparent
            });

            bar.appendChild(tooltip); // Append the tooltip to the bar
            visualization.appendChild(bar);
        });

        // Reset stats
        section.querySelector('.swaps').textContent = '0';
        section.querySelector('.comparisons').textContent = '0';
        section.querySelector('.time').textContent = '0ms';
    }

     // Function to start sorting all sections
async function startSorting() {
    const sections = document.querySelectorAll('.sorting-section');
    const startButton = document.querySelector('.start-button');
    
     // Clear previous results
     const resultsTableBody = document.querySelector('.results-table tbody');
    resultsTableBody.innerHTML = ''; // Clear the table body

    // Disable the start button
    startButton.disabled = true;
 // Get the common speed value
 const speed = commonSpeedSlider.value;
    // Create an array of promises for sorting each section
    const sortingPromises = Array.from(sections).map(async (section) => {
        console.log("Starting sorting for section:", section); // Debug log
        const algorithm = section.querySelector('.algorithm-dropdown').value;
        const visualization = section.querySelector('.visualization');
        // const speed = section.querySelector('.speed-control').value;

        // Call the appropriate sorting function based on the selected algorithm
        if (algorithm === 'bubble') {
            await bubbleSort(visualization, speed);
        } else if (algorithm === 'quick') {
            await quickSort(visualization, speed);
        } else if (algorithm === 'merge') {
            await mergeSort(visualization, speed);
        } else if (algorithm === 'insertion') {
            await insertionSort(visualization, speed); // New Insertion Sort
        } else if (algorithm === 'selection') {
            await selectionSort(visualization, speed); // New Selection Sort
        }
    });

    // Wait for all sorting promises to complete
    await Promise.all(sortingPromises);

    // Re-enable the start button after sorting is complete
    startButton.disabled = false;
}

    async function updateVisualization(bars, array, index1, index2, speed) {
        // Update the heights of the bars based on the current array state
        for (let i = 0; i < array.length; i++) {
            bars[i].style.height = `${array[i] * 2}px`; // Scale the height for better visibility
            bars[i].style.backgroundColor = (i === index1 || i === index2) ? '#e74c3c' : '#3498db'; // Highlight the bars being compared
        }
        await new Promise(resolve => setTimeout(resolve, (11 - speed) * 100)); // Adjust speed of visualization
    }

    function updateStats(section, swaps, comparisons, timeTaken) {
    section.querySelector('.swaps').textContent = swaps;
    section.querySelector('.comparisons').textContent = comparisons;
    section.querySelector('.time').textContent = `${timeTaken.toFixed(2)}ms`;
    const visualization = section.querySelector('.visualization');
    const sortedArray = Array.from(visualization.children).map(bar => parseInt(bar.style.height) / 2);

    // Add a new row to the results table
    addResultToTable(section.querySelector('.algorithm-dropdown').value, swaps, comparisons, timeTaken, sortedArray);
}
function addResultToTable(algorithm, swaps, comparisons, timeTaken, sortedArray) {
    const resultsTableBody = document.querySelector('.results-table tbody');

    // Create a new row
    const newRow = document.createElement('tr');

    // Create cells for each piece of data
    newRow.innerHTML = `
        <td>${algorithm.charAt(0).toUpperCase() + algorithm.slice(1)} Sort</td>
        <td>${swaps}</td>
        <td>${comparisons}</td>
        <td>${timeTaken.toFixed(2)}ms</td>
        <td>${sortedArray.join(', ')}</td>
    `;

    // Append the new row to the table body
    resultsTableBody.appendChild(newRow);
}

    // Bubble Sort function
    async function bubbleSort(visualization, speed) {
        const bars = visualization.children;
        const array = Array.from(bars).map(bar => parseInt(bar.style.height) / 2); // Get the original values
        const n = array.length;

        let swaps = 0;
        let comparisons = 0;
        let timeTaken = performance.now();

        for (let i = 0; i < n - 1; i++) {
            for (let j = 0; j < n - i - 1; j++) {
                comparisons++;
                if (array[j] > array[j + 1]) {
                    // Swap
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                    swaps++;

                    // Update visualization
                    await updateVisualization(bars, array, j, j + 1, speed);
                }
            }
        }
        timeTaken = performance.now() - timeTaken;
        updateStats(visualization.parentElement, swaps, comparisons, timeTaken); // Pass the section to update stats

    }

    // Quick Sort function
    async function quickSort(visualization, speed) {
        return new Promise(async (resolve) => {
            const bars = visualization.children;
            const array = Array.from(bars).map(bar => parseInt(bar.style.height) / 2); // Get the original values

            let swaps = 0;
            let comparisons = 0;
            let timeTaken = performance.now();

            const sort = async (arr, left, right) => {
                if (left < right) {
                    const pivotIndex = await partition(arr, left, right);
                    await sort(arr, left, pivotIndex - 1);
                    await sort(arr, pivotIndex + 1, right);
                }
            };

            const partition = async (arr, left, right) => {
                const pivot = arr[right];
                let i = left - 1;

                for (let j = left; j < right; j++) {
                    comparisons++;
                    if (arr[j] < pivot) {
                        i++;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        swaps++;

                        // Update visualization
                        await updateVisualization(bars, arr, i, j, speed);
                    }
                }
                [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
                swaps++;

                // Update visualization
                await updateVisualization(bars, arr, i + 1, right, speed);
                return i + 1;
            };

            await sort(array, 0, array.length - 1); // Await the sorting process
            timeTaken = performance.now() - timeTaken;
            updateStats(visualization.parentElement, swaps, comparisons, timeTaken);
            resolve();
        });
    }

    // Merge Sort function
    async function mergeSort(visualization, speed) {
        return new Promise(async (resolve) => {
            const bars = visualization.children;
            const array = Array.from(bars).map(bar => parseInt(bar.style.height) / 2); // Get the original values

            let swaps = 0;
            let comparisons = 0;
            let timeTaken = performance.now();

            const sort = async (arr) => {
                if (arr.length <= 1) return arr;

                const mid = Math.floor(arr.length / 2);
                const left = await sort(arr.slice(0, mid));
                const right = await sort(arr.slice(mid));

                return await merge(left, right);
            };

            const merge = async (left, right) => {
                const result = [];
                let leftIndex = 0;
                let rightIndex = 0;

                while (leftIndex < left.length && rightIndex < right.length) {
                    comparisons++;
                    if (left[leftIndex] < right[rightIndex]) {
                        result.push(left[leftIndex]);
                        leftIndex++;
                    } else {
                        result.push(right[rightIndex]);
                        rightIndex++;
                    }
                }

                while (leftIndex < left.length) {
                    result.push(left[leftIndex]);
                    leftIndex++;
                }

                while (rightIndex < right.length) {
                    result.push(right[rightIndex]);
                    rightIndex++;
                }

                // Update visualization
                await updateVisualization(bars, result, null, null, speed); // Update visualization with merged result
                return result;
            };

            await sort(array); // Await the sorting process
            timeTaken = performance.now() - timeTaken;
            updateStats(visualization.parentElement, swaps, comparisons, timeTaken); // Pass the section to update stats
            resolve(); // Resolve the promise when sorting is complete
        });
    }
    async function insertionSort(visualization, speed) {
    const bars = visualization.children;
    const array = Array.from(bars).map(bar => parseInt(bar.style.height) / 2); // Get the original values

    let swaps = 0;
    let comparisons = 0;
    let timeTaken = performance.now();

    for (let i = 1; i < array.length; i++) {
        let key = array[i];
        let j = i - 1;

        // Move elements of array[0..i-1] that are greater than key
        while (j >= 0 && array[j] > key) {
            comparisons++;
            array[j + 1] = array[j];
            swaps++;

            // Update visualization
            await updateVisualization(bars, array, j, j + 1, speed);
            j--;
        }
        array[j + 1] = key;

        // Update visualization for the key placement
        await updateVisualization(bars, array, j + 1, i, speed);
    }

    timeTaken = performance.now() - timeTaken;
    updateStats(visualization.parentElement, swaps, comparisons, timeTaken);
}

async function selectionSort(visualization, speed) {
    const bars = visualization.children;
    const array = Array.from(bars).map(bar => parseInt(bar.style.height) / 2); // Get the original values

    let swaps = 0;
    let comparisons = 0;
    let timeTaken = performance.now();

    for (let i = 0; i < array.length - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < array.length; j++) {
            comparisons++;
            if (array[j] < array[minIndex]) {
                minIndex = j;
            }
        }

        // Swap the found minimum element with the first element
        if (minIndex !== i) {
            [array[i], array[minIndex]] = [array[minIndex], array[i]];
            swaps++;

            // Update visualization
            await updateVisualization(bars, array, i, minIndex, speed);
        }
    }

    timeTaken = performance.now() - timeTaken;
    updateStats(visualization.parentElement, swaps, comparisons, timeTaken);
}



    // Event listeners
    addSectionButton.addEventListener('click', createSortingSection);
    startButton.addEventListener('click', startSorting);
    randomizeAllButton.addEventListener('click', () => {
        const sections = document.querySelectorAll('.sorting-section');
    const arraySize = 20; // Set the number of bars to 20
    const randomArray = Array.from({ length: arraySize }, () => Math.floor(Math.random() * 100));

    sections.forEach(section => {
        // Update each section with the same random array
        const visualization = section.querySelector('.visualization');
        visualization.innerHTML = ''; // Clear previous visualization

        randomArray.forEach(value => {
            const bar = document.createElement('div');
            bar.style.height = `${value * 2}px`; // Scale the height for better visibility
            bar.style.width = '30px'; // Adjusted width for each bar
            bar.style.backgroundColor = '#3498db'; // Color of the bars
            bar.style.margin = '0 2px'; // Spacing between bars
            bar.style.borderRadius = '5px'; // Rounded corners for bars
            bar.style.position = 'relative'; // Set position to relative for tooltip positioning

            // Create tooltip
            const tooltip = document.createElement('span');
            tooltip.textContent = value; // Set the tooltip text to the value
            tooltip.style.position = 'absolute';
            tooltip.style.bottom = '100%'; // Position above the bar
            tooltip.style.left = '50%'; // Center the tooltip
            tooltip.style.transform = 'translateX(-50%)'; // Center the tooltip
            tooltip.style.backgroundColor = '#333'; // Tooltip background color
            tooltip.style.color = '#fff'; // Tooltip text color
            tooltip.style.padding = '5px';
            tooltip.style.borderRadius = '5px';
            tooltip.style.visibility = 'hidden'; // Hide tooltip by default
            tooltip.style.opacity = '0'; // Make it transparent
            tooltip.style.transition = 'opacity 0.3s'; // Smooth transition for visibility

            // Show tooltip on hover
            bar.addEventListener('mouseenter', () => {
                tooltip.style.visibility = 'visible';
                tooltip.style.opacity = '1'; // Make it visible
            });

            // Hide tooltip when not hovering
            bar.addEventListener('mouseleave', () => {
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0'; // Make it transparent
            });

            bar.appendChild(tooltip); // Append the tooltip to the bar
            visualization.appendChild(bar);
        });

        // Reset stats
        section.querySelector('.swaps').textContent = '0';
        section.querySelector('.comparisons').textContent = '0';
        section.querySelector('.time').textContent = '0ms';
    });
});

    commonSpeedSlider.addEventListener('input', (event) => {
        const speedValue = event.target.value;
        const sections = document.querySelectorAll('.sorting-section');
        sections.forEach(section => {
            const speedControl = section.querySelector('.speed-control');
            speedControl.value = speedValue; // Update individual speed controls if needed
        });
    });
});

</script>
</body>
</html>